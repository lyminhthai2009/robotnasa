#include <QTRSensors.h>
#include "BluetoothSerial.h"

#if !defined(CONFIG_BT_ENABLED) || !defined(CONFIG_BLUEDROID_ENABLED)
#error Bluetooth is not enabled! Please run `make menuconfig` to and enable it
#endif

// =================================================================
// == CẤU HÌNH PHẦN CỨNG CỦA BẠN ==
// =================================================================
#define PWM_PIN_L_A 2
#define PWM_PIN_L_B 10
#define PWM_PIN_R_A 6
#define PWM_PIN_R_B 5

// Kênh PWM cho ESP32
#define left_motor_channel_a 0
#define left_motor_channel_b 1
#define right_motor_channel_a 2
#define right_motor_channel_b 3

// Cảm biến dò line
#define SENSOR_1_PIN 4
#define SENSOR_2_PIN 3
#define SENSOR_3_PIN 1
#define SENSOR_4_PIN 0
const uint8_t SensorCount = 4; // Thay đổi từ 5 thành 4

// Đèn LED
#define W_LED_ON 20
#define IR_LED_ON 21

// =================================================================
// == CÁC BIẾN TOÀN CỤC ==
// =================================================================

QTRSensors qtr;
BluetoothSerial SerialBT;

uint16_t sensorValues[SensorCount];

// Biến cho PID
float Kp = 0;
float Ki = 0;
float Kd = 0;
uint8_t multiP = 1;
uint8_t multiI = 1;
uint8_t multiD = 1;
float Pvalue;
float Ivalue;
float Dvalue;

boolean onoff = false; // Trạng thái bật/tắt của robot

// Biến cho việc đọc Bluetooth
int val, cnt = 0, v[3];

// Biến cho việc tính toán PID
uint16_t position;
int P, D, I, previousError, error;
int lsp, rsp; // Tốc độ trái và phải
int lfspeed = 230; // Tốc độ cơ sở

// Cấu hình PWM
const int pwm_freq = 5000; // Tần số PWM
const int pwm_resolution = 8; // Độ phân giải 8-bit (0-255)

// =================================================================
// == HÀM SETUP - CHẠY MỘT LẦN KHI KHỞI ĐỘNG ==
// =================================================================
void setup()
{
  Serial.begin(115200);
  
  // --- Cấu hình Motor PWM ---
  ledcSetup(left_motor_channel_a, pwm_freq, pwm_resolution);
  ledcSetup(left_motor_channel_b, pwm_freq, pwm_resolution);
  ledcSetup(right_motor_channel_a, pwm_freq, pwm_resolution);
  ledcSetup(right_motor_channel_b, pwm_freq, pwm_resolution);

  ledcAttachPin(PWM_PIN_L_A, left_motor_channel_a);
  ledcAttachPin(PWM_PIN_L_B, left_motor_channel_b);
  ledcAttachPin(PWM_PIN_R_A, right_motor_channel_a);
  ledcAttachPin(PWM_PIN_R_B, right_motor_channel_b);
  
  // --- Cấu hình Đèn LED ---
  pinMode(W_LED_ON, OUTPUT);
  pinMode(IR_LED_ON, OUTPUT);
  digitalWrite(IR_LED_ON, HIGH); // Bật đèn hồng ngoại cho cảm biến

  // --- Cấu hình Cảm biến QTR ---
  qtr.setTypeRC(); // Hoặc setTypeAnalog() nếu cảm biến của bạn là analog
  qtr.setSensorPins((const uint8_t[]){SENSOR_1_PIN, SENSOR_2_PIN, SENSOR_3_PIN, SENSOR_4_PIN}, SensorCount);
  
  delay(500);
  
  // --- Hiệu chỉnh cảm biến (Calibration) ---
  digitalWrite(W_LED_ON, HIGH); // Bật đèn trắng báo hiệu đang calibrate
  for (uint16_t i = 0; i < 400; i++)
  {
    qtr.calibrate();
  }
  digitalWrite(W_LED_ON, LOW); // Tắt đèn trắng báo hiệu đã calibrate xong

  Serial.println("Calibration finished. Values:");
  for (uint8_t i = 0; i < SensorCount; i++)
  {
    Serial.print(qtr.calibrationOn.minimum[i]);
    Serial.print(' ');
  }
  Serial.println();
  for (uint8_t i = 0; i < SensorCount; i++)
  {
    Serial.print(qtr.calibrationOn.maximum[i]);
    Serial.print(' ');
  }
  Serial.println();
  
  // --- Khởi động Bluetooth ---
  SerialBT.begin("LineFollowerRobot"); // Đặt tên cho Bluetooth
  Serial.println("Bluetooth Started! Ready to pair...");

  delay(1000);
}

// =================================================================
// == HÀM LOOP - CHẠY LIÊN TỤC ==
// =================================================================
void loop()
{
  if (SerialBT.available()){
    valuesread();
    processing();
  }
  
  if (onoff == true){
    robot_control();
  }
  else {
    // Dừng động cơ nếu robot đang ở trạng thái OFF
    motor_drive(0, 0);
  }
}

// =================================================================
// == CÁC HÀM CHỨC NĂNG ==
// =================================================================

void robot_control(){
  // Đọc giá trị từ cảm biến và tính toán vị trí của vạch đen
  // Giá trị từ 0 đến 3000 (vì có 4 cảm biến, (4-1)*1000)
  position = qtr.readLineBlack(sensorValues);
  
  // Lỗi = Giá trị trung tâm (1500) - Vị trí hiện tại
  error = 1500 - position;

  // Xử lý trường hợp robot chạy ra khỏi line
  // Đoạn code này trong file gốc có thể gây kẹt vòng lặp, có thể bỏ đi
  // và để PID tự xử lý. Nếu cần thiết có thể thêm lại logic tốt hơn.
  
  PID_Linefollow(error);
}

void PID_Linefollow(int error){
    P = error;
    I = I + error; // Tích lũy lỗi
    D = error - previousError;
    
    Pvalue = (Kp / pow(10, multiP)) * P;
    Ivalue = (Ki / pow(10, multiI)) * I;
    Dvalue = (Kd / pow(10, multiD)) * D; 

    float PIDvalue = Pvalue + Ivalue + Dvalue;
    previousError = error;

    // Tính tốc độ cho mỗi bánh xe
    lsp = lfspeed - PIDvalue;
    rsp = lfspeed + PIDvalue;

    // Giới hạn tốc độ trong khoảng -255 đến 255
    lsp = constrain(lsp, -255, 255);
    rsp = constrain(rsp, -255, 255);
    
    motor_drive(lsp, rsp);
}

// HÀM ĐIỀU KHIỂN ĐỘNG CƠ - ĐÃ VIẾT LẠI CHO PHẦN CỨNG CỦA BẠN
void motor_drive(int left_speed, int right_speed){
  // Điều khiển motor trái
  if(left_speed > 0){ // Chạy tới
    ledcWrite(left_motor_channel_a, left_speed);
    ledcWrite(left_motor_channel_b, 0);
  }
  else { // Chạy lùi
    ledcWrite(left_motor_channel_a, 0);
    ledcWrite(left_motor_channel_b, abs(left_speed));
  }
  
  // Điều khiển motor phải
  if(right_speed > 0){ // Chạy tới
    ledcWrite(right_motor_channel_a, right_speed);
    ledcWrite(right_motor_channel_b, 0);
  }
  else { // Chạy lùi
    ledcWrite(right_motor_channel_a, 0);
    ledcWrite(right_motor_channel_b, abs(right_speed));
  }
}

// --- CÁC HÀM BLUETOOTH (Giữ nguyên từ code gốc) ---

// Đọc 2 byte từ Bluetooth
void valuesread() {
  val = SerialBT.read();
  cnt++;
  v[cnt] = val;
  if (cnt == 2)
    cnt = 0;
}

// Xử lý lệnh nhận được
void processing() {
  int a = v[1];
  if (a == 1) { Kp = v[2]; }
  if (a == 2) { multiP = v[2]; }
  if (a == 3) { Ki = v[2]; }
  if (a == 4) { multiI = v[2]; }
  if (a == 5) { Kd = v[2]; }
  if (a == 6) { multiD = v[2]; }
  if (a == 7) { onoff = v[2]; }
}
