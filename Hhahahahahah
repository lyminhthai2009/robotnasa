#include <QTRSensors.h>

// =================================================================
// == CẤU HÌNH PHẦN CỨNG CỦA BẠN ==
// =================================================================
#define PWM_PIN_L_A 2
#define PWM_PIN_L_B 10
#define PWM_PIN_R_A 6
#define PWM_PIN_R_B 5

// Cảm biến dò line
#define SENSOR_1_PIN 4
#define SENSOR_2_PIN 3
#define SENSOR_3_PIN 1
#define SENSOR_4_PIN 0
const uint8_t SensorCount = 4;

// Đèn LED
#define W_LED_ON 20
#define IR_LED_ON 21

// =================================================================
// == CÁC BIẾN TOÀN CỤC ==
// =================================================================

QTRSensors qtr;
uint16_t sensorValues[SensorCount];

// ----- CÁC THÔNG SỐ PID - BẠN CẦN CHỈNH CÁC THÔNG SỐ NÀY -----
float Kp = 0.2;
float Ki = 0;
float Kd = 1.0;
// -----------------------------------------------------------

int P, D, I = 0, previousError = 0, error;
int lsp, rsp;
int lfspeed = 180;

// Cấu hình PWM
const int pwm_freq = 5000;
const int pwm_resolution_bits = 8; // Độ phân giải 8-bit (0-255)

// =================================================================
// == HÀM SETUP - CHẠY MỘT LẦN KHI KHỞI ĐỘNG ==
// =================================================================
void setup()
{
  Serial.begin(115200);
  
  // --- THAY ĐỔI LỚN: Cấu hình PWM bằng analogWrite ---
  // Không cần ledcSetup hay ledcAttachPin nữa!
  // Chỉ cần cài đặt tần số và độ phân giải chung cho analogWrite
  analogWriteFreq(pwm_freq);
  analogWriteResolution(pwm_resolution_bits);
  
  // --- Cấu hình Đèn LED ---
  pinMode(W_LED_ON, OUTPUT);
  pinMode(IR_LED_ON, OUTPUT);
  digitalWrite(IR_LED_ON, HIGH);

  // --- Cấu hình Cảm biến QTR ---
  qtr.setTypeRC();
  qtr.setSensorPins((const uint8_t[]){SENSOR_1_PIN, SENSOR_2_PIN, SENSOR_3_PIN, SENSOR_4_PIN}, SensorCount);
  
  delay(500);
  
  // --- Hiệu chỉnh cảm biến (Calibration) ---
  Serial.println("Bat dau Calibration...");
  digitalWrite(W_LED_ON, HIGH);
  for (uint16_t i = 0; i < 400; i++)
  {
    qtr.calibrate();
  }
  digitalWrite(W_LED_ON, LOW);

  Serial.println("Calibration da xong. Robot se bat dau chay.");
  delay(1000);
}

// =================================================================
// == HÀM LOOP - CHẠY LIÊN TỤC ==
// =================================================================
void loop()
{
  // Đọc cảm biến, tính toán lỗi
  position = qtr.readLineBlack(sensorValues);
  error = 1500 - position;
  
  // Tính toán PID
  P = error;
  I = I + error;
  D = error - previousError;
  previousError = error;
  
  float PIDvalue = (Kp * P) + (Ki * I) + (Kd * D);

  // Tính toán tốc độ hai bánh
  lsp = lfspeed - PIDvalue;
  rsp = lfspeed + PIDvalue;

  // Giới hạn tốc độ
  lsp = constrain(lsp, -255, 255);
  rsp = constrain(rsp, -255, 255);
  
  // Điều khiển động cơ
  motor_drive(lsp, rsp);
}

// =================================================================
// == HÀM ĐIỀU KHIỂN ĐỘNG CƠ (Sử dụng analogWrite) ==
// =================================================================
void motor_drive(int left_speed, int right_speed){
  // Điều khiển motor trái
  if(left_speed > 0){ // Chạy tới
    analogWrite(PWM_PIN_L_A, left_speed);
    analogWrite(PWM_PIN_L_B, 0);
  }
  else { // Chạy lùi
    analogWrite(PWM_PIN_L_A, 0);
    analogWrite(PWM_PIN_L_B, abs(left_speed));
  }
  
  // Điều khiển motor phải
  if(right_speed > 0){ // Chạy tới
    analogWrite(PWM_PIN_R_A, right_speed);
    analogWrite(PWM_PIN_R_B, 0);
  }
  else { // Chạy lùi
    analogWrite(PWM_PIN_R_A, 0);
    analogWrite(PWM_PIN_R_B, abs(right_speed));
  }
}
