#include <QTRSensors.h>

// =================================================================
// == CẤU HÌNH PHẦN CỨNG CỦA BẠN ==
// =================================================================
#define PWM_PIN_L_A 2
#define PWM_PIN_L_B 10
#define PWM_PIN_R_A 6
#define PWM_PIN_R_B 5

// Kênh PWM cho ESP32
#define left_motor_channel_a 0
#define left_motor_channel_b 1
#define right_motor_channel_a 2
#define right_motor_channel_b 3

// Cảm biến dò line
#define SENSOR_1_PIN 4
#define SENSOR_2_PIN 3
#define SENSOR_3_PIN 1
#define SENSOR_4_PIN 0
const uint8_t SensorCount = 4;

// Đèn LED
#define W_LED_ON 20
#define IR_LED_ON 21

// =================================================================
// == CÁC BIẾN TOÀN CỤC ==
// =================================================================

QTRSensors qtr;
uint16_t sensorValues[SensorCount];

// ----- CÁC THÔNG SỐ PID - BẠN CẦN CHỈNH CÁC THÔNG SỐ NÀY -----
// Bạn sẽ phải thay đổi các giá trị này và nạp lại code để tinh chỉnh robot.
float Kp = 0.2;
float Ki = 0;
float Kd = 1.0;
// -----------------------------------------------------------

float Pvalue;
float Ivalue;
float Dvalue;

// Biến cho việc tính toán PID
uint16_t position;
int P, D, I = 0, previousError = 0, error;
int lsp, rsp; // Tốc độ trái và phải
int lfspeed = 180; // Tốc độ cơ sở, bắt đầu với giá trị thấp (vd: 150-180)

// Cấu hình PWM
const int pwm_freq = 5000; // Tần số PWM
const int pwm_resolution = 8; // Độ phân giải 8-bit (0-255)

// =================================================================
// == HÀM SETUP - CHẠY MỘT LẦN KHI KHỞI ĐỘNG ==
// =================================================================
void setup()
{
  Serial.begin(115200);
  
  // --- Cấu hình Motor PWM ---
  ledcSetup(left_motor_channel_a, pwm_freq, pwm_resolution);
  ledcSetup(left_motor_channel_b, pwm_freq, pwm_resolution);
  ledcSetup(right_motor_channel_a, pwm_freq, pwm_resolution);
  ledcSetup(right_motor_channel_b, pwm_freq, pwm_resolution);

  ledcAttachPin(PWM_PIN_L_A, left_motor_channel_a);
  ledcAttachPin(PWM_PIN_L_B, left_motor_channel_b);
  ledcAttachPin(PWM_PIN_R_A, right_motor_channel_a);
  ledcAttachPin(PWM_PIN_R_B, right_motor_channel_b);
  
  // --- Cấu hình Đèn LED ---
  pinMode(W_LED_ON, OUTPUT);
  pinMode(IR_LED_ON, OUTPUT);
  digitalWrite(IR_LED_ON, HIGH); // Bật đèn hồng ngoại cho cảm biến

  // --- Cấu hình Cảm biến QTR ---
  qtr.setTypeRC(); // Hoặc setTypeAnalog() nếu cảm biến của bạn là analog
  qtr.setSensorPins((const uint8_t[]){SENSOR_1_PIN, SENSOR_2_PIN, SENSOR_3_PIN, SENSOR_4_PIN}, SensorCount);
  
  delay(500);
  
  // --- Hiệu chỉnh cảm biến (Calibration) ---
  Serial.println("Bat dau Calibration...");
  digitalWrite(W_LED_ON, HIGH); // Bật đèn trắng báo hiệu đang calibrate
  for (uint16_t i = 0; i < 400; i++)
  {
    qtr.calibrate();
  }
  digitalWrite(W_LED_ON, LOW); // Tắt đèn trắng báo hiệu đã calibrate xong

  Serial.println("Calibration da xong. Robot se bat dau chay.");
  
  delay(1000);
}

// =================================================================
// == HÀM LOOP - CHẠY LIÊN TỤC ==
// =================================================================
void loop()
{
  // Robot sẽ luôn chạy sau khi setup xong
  robot_control();
}

// =================================================================
// == CÁC HÀM CHỨC NĂNG ==
// =================================================================

void robot_control(){
  // Đọc giá trị từ cảm biến và tính toán vị trí của vạch đen
  // Giá trị từ 0 đến 3000 (vì có 4 cảm biến, (4-1)*1000)
  position = qtr.readLineBlack(sensorValues);
  
  // Lỗi = Giá trị trung tâm (1500) - Vị trí hiện tại
  error = 1500 - position;
  
  PID_Linefollow(error);
}

void PID_Linefollow(int error){
    P = error;
    I = I + error; // Tích lũy lỗi
    D = error - previousError;
    
    // Ở đây ta không cần `multiP` nữa, dùng trực tiếp Kp, Ki, Kd
    Pvalue = Kp * P;
    Ivalue = Ki * I;
    Dvalue = Kd * D; 

    float PIDvalue = Pvalue + Ivalue + Dvalue;
    previousError = error;

    // Tính tốc độ cho mỗi bánh xe
    lsp = lfspeed - PIDvalue;
    rsp = lfspeed + PIDvalue;

    // Giới hạn tốc độ trong khoảng -255 đến 255
    lsp = constrain(lsp, -255, 255);
    rsp = constrain(rsp, -255, 255);
    
    motor_drive(lsp, rsp);
}

// HÀM ĐIỀU KHIỂN ĐỘNG CƠ
void motor_drive(int left_speed, int right_speed){
  // Điều khiển motor trái
  if(left_speed > 0){ // Chạy tới
    ledcWrite(left_motor_channel_a, left_speed);
    ledcWrite(left_motor_channel_b, 0);
  }
  else { // Chạy lùi
    ledcWrite(left_motor_channel_a, 0);
    ledcWrite(left_motor_channel_b, abs(left_speed));
  }
  
  // Điều khiển motor phải
  if(right_speed > 0){ // Chạy tới
    ledcWrite(right_motor_channel_a, right_speed);
    ledcWrite(right_motor_channel_b, 0);
  }
  else { // Chạy lùi
    ledcWrite(right_motor_channel_a, 0);
    ledcWrite(right_motor_channel_b, abs(right_speed));
  }
}
